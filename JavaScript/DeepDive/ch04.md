# ch04. 변수

## 자바스크립트 엔진이 코드를 해석하고 실행하는 방법

- 자바스크립트 엔진이 자바스크립트 코드를 계산(= 평가, evaluation)하려면
  1. 기호(리터럴, 연산자)의 의미를 알고 있어야 하고
  2. 10 + 20 이라는 식(= 표현식, expression)의 의미를 해석(= 파싱, parsing)할 수 있어야 한다.
- CPU를 사용해 연산, 메모리를 사용해 데이터를 기억한다.

### 메모리 (memory)

- 데이터를 저장할 수 있는 메모리 셀의 집합체
- 메모리 셀 하나의 크기는 1byte(= 8bit)
  - 1byte 단위로 데이터를 저장하거나 읽는다.
- 각 셀은 고유의 메모리 주소(= 메모리 공간의 위치)를 갖고,이는 0~메모리 크기 만큼 정수로 표현된다.
- 컴퓨터는 모든 데이터를 2진수로 처리한다.
  - 메모리에 저장되는 데이터는 데이터 종류에 상관없이 모두 2진수로 저장된다.

## 변수가 필요한 이유?

- 변수가 없다면 메모리 주소를 통해 값에 직접 접근해야 한다.
  - 그러나 이는 아주 치명적인 오류를 발생시킬 수 있는 굉장히 '위험한' 일이다.
- 그러므로 JavaScript는 개발자의 직접적인 메모리 제어를 허용하지 않는다. (**매니지드 언어**)
  - 메모리 제어를 허용해도 값이 저장될 메모리 주소는 코드가 실행될 때 메모리의 상황에 따라 임의로 결정되어, 같은 컴퓨터에서 같은 코드를 실행해도 값이 저장될 메모리 주소는 다 다르므로 의미가 없다.
- 따라서 프로그래밍 언어는 기억하고싶은 값을 메모리에 저장하고, 저장된 값을 읽어 재사용하기 위해 변수라는 메커니즘을 제공한다.

### 변수

- 변수는 하나의 값을 저장하기 위해 확보환 메모리 공간 자체 or 그 메모리 공간을 식별하기 위해 붙인 이름
- 값의 위치를 가리키는 상징적인 이름
  - (= 값이 저장된 메모리 공간에 이름을 붙인 것)
- 변수 이름으로 참조를 요청하면 JS 엔진은 변수 이름과 매핑된 메모리 주소를 통해 메모리 공간에 접근해서 저장된 값을 반환한다.

> ✅ 개발자는 변수를 통해 안전하게 값에 접근할 수 있다.

### 변수 관련 용어

- 변수 이름(= 식별자): 메모리 공간에 저장된 값을 식별할 수 있는 고유한 이름
- 변수 값: 변수에 저장된 값
- 할당(= 대입, 저장): 변수에 값을 저장하는 것
- 참조: 변수에 저장된 값을 읽어 들이는 것

### 식별자

- 변수 이름을 '식별자'라고도 한다. 식별자는 어떤 값을 구별해 식별할 수 있는 고유한 이름을 의미한다.
- 식별자는 값이 아니라 메모리 주소를 기억하고 있다.
  - 식별자로 값을 구별해 식별한다는 것은, 식별자가 기억하고 있는 메모리 주소를 통해 메모리 공간에 저장된 값에 접근할 수 있다는 의미이다.
  - 변수, 함수, 클래스 등의 이름은 모두 식별자이다.

## 변수 선언, 값의 할당

- 변수 선언이란 값을 저장하기 위한 메모리 공간을 확보하고, 변수 이름과 확보된 메모리 공간의 주소를 연결해서 값을 저장할 수 있게 준비하는 것이다.
  - 변수 선언으로 확보된 메모리 공간을 해제 되기 전까지 그 누구도 사용할 수 없다.

```js
var score; // 변수 선언
```

- JS 엔진이 var라는 키워드를 만나면 변수 이름을 등록하고 값을 저장할 메모리 공간을 확보한다.
- 위의 코드에서는 변수 선언 후 값은 할당하지 않았으므로 비어있을 것 같지만, 자바스크립트 엔진에 의해 **'undefined'** 라는 값이 암묵적으로 할당되어 초기화된다.

```js
var score = 100; // 변수 선언과 동시에 값 초기화하기
```

- 🚨 변수 선언과 값의 할당을 **하나의 문으로 단축해 표현해도 2개의 문으로 나누어 각각 실행한다.**
  - 변수 선언과 값의 실행 시점이 다르다.
- **변수 선언은 런타임(소스코드가 한 줄씩 순차적으로 실행되는 시점) 이전에 먼저 실행된다.**
  - JS 엔진은 모든 선언문(변수, 함수 선언문 등)을 소스코드 평과 과정에서 먼저 실행한다.
  - 그러므로 변수 선언이 소스코드 어디에 위치하던 다른 코드보다 먼저 실행된다.
- 값의 할당은 런타임에 이루어진다. (실행된다.)

### ★ 변수 호이스팅 (variable hoisting)

- 변수 선언문이 코드의 선두로 끌어 올려진 것처럼 동작하는 것
  - 사실 모든 식별자(변수, 함수, 클래스 ...)는 호이스팅이 된다.
  - 모든 선언문은 런타임 이전 단계에서 먼저 실행되기 때문이다.

## 변수에 값을 할당할 때와 재할당할 때

### 변수에 값을 할당할 때

- 이전 값인 'undefined'가 저장되어 있는 메모리 공간을 지우고 할당 값 100을 새롭게 저장하는 것이 아닌 **새로운 메모리 공간을 확보**하고, 그 곳에 할당 값 100을 저장한다.

### 값을 재할당할 때

- 재할당이란 이미 값이 할당된 변수에 새로운 값을 또다시 할당하는 것
- 만약 값을 재할당할 수 없어 변수에 저장된 값을 변경할 수 없다면, 그것은 '상수'라고 한다.
  - 상수는 한번 정해지면 변하지 않는 값이다. (es6에 도입된 'const' 키워드)
- 재할당 후 이전의 값은 더 이상 쓰이지 않으니 필요하지 않은 것이다.
  - 이렇게 불필요한 값들은 가비지 콜렉터에 의해 메모리에서 자동 해제된다.

## 언매니지드 언어 vs 매니지드 언어

- 프로그래밍 언어는 메모리 관리 방식에 따라 2가지로 분류할 수 있다.

### Unmanaged Language (언매니지드 언어)

- 개발자가 명시적으로 메모리를 할당, 해제하기 위해 `malloc()`과 `free()` 같은 저수분 메모리 제어 기능을 제공하는 언어
- 메모리 제어를 개발자가 주도할 수 있다.
- ex) c언어

### Managed Language (매니지드 언어)

- 메모리의 할당, 해제를 위한 메모리 관리 기능을 언어 차원에서 담당하는 언어
- 개발자의 직접적인 메모리 제어를 허용하지 않는다.
- 더이상 사용하지 않는 메모리의 해제는 가비지 콜렉터가 수행한다.
- ex) JavaScript

### + Garbage collector (가비지 콜렉터)

- 애플리케이션이 할당한 메모리 공간을 주기적으로 검사해 더이상 사용되지 않는 메모리(= 어떤 식별자도 참조하지 않는 메모리 공간)를 해제하는 기능
