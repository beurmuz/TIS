# 정렬 (Sorting)
- 데이터를 특정한 기준에 따라 순서대로 나열하는 것
- 다양한 정렬 방법이 있음

## 1. 선택 정렬 (Selection sort)
- 데이터가 무작위로 있을 때, 가장 작은 데이터를 선택해 맨 앞에 있는 데이터와 바꾸는 과정을 반복하는 방법
- **매번 가장 작은 것을 선택**하는 방법

### 코드 
```js
function selectionSort(N, nums) {
    for(let i = 0; i < N-1; i++) {
        let min_index = i;
        for(let j = i+1; j < N; j++) {
            if(nums[min_index] > nums[j]) min_index = j;
        }
        [nums[i], nums[min_index]] = [nums[min_index], nums[i]]; // 두 데이터 스와핑
        console.log(nums);
    }
}

const nums = [9, 5, 4, 7, 1, 6, 2, 3, 8, 0];
console.log(selectionSort(10, nums));
```

### 시간 복잡도
- `N-1`번 만큼 가장 작은 수를 찾아 위치를 옮겨야 함
- 비교 연산이 필요함
- 연산 횟수는 `N + (N + 1) + (N + 2) + (N + 3) + ... + 2`이므로 `N + (N + 1)/2`번의 연산을 수행한다고 보면 됨
- 즉, `O(N^2)`
- 소스코드 상 이중 반복문이 사용되었으니 `O(N^2)`이라 생각해도 됨

## 2. 삽입 정렬 (Insertion Sort)
- 특정한 데이터를 적절한 위치에 '삽입'하는 방법
- 데이터가 거의 정렬되어 있을 때 훨씬 효율적임
- 선택 정렬은 무조건 모든 원소를 비교하고 위치를 바꾸지만, 삽입 정렬은 그렇지 않음
- 삽입 정렬은 두번째 데이터부터 정렬을 시작함

### 코드
```js
function insertionSort(N, nums) {
    for(let i = 1; i < N; i++) {
        for(let j = i-1; j >= 0; j--) {
            if(nums[j] < nums[j-1]) { // nums[i]가 정렬하려는 값
                [nums[j], nums[j-1]] = [nums[j-1], nums[j]];
            }
        }
        console.log(nums);
    }
}

const nums = [9, 5, 4, 7, 1, 6, 2, 3, 8, 0];
console.log(insertionSort(10, nums));
```

### 시간 복잡도
- `O(N^2)`
- 리스트의 데이터가 거의 정렬되어 있는 상태라면 `O(N)`
- 거의 정렬된 상태로 입력이 주어지는 문제라면 퀵 정렬 등의 여러 알고리즘 보다도 삽입 정렬을 쓰는 것이 정답 확률이 높아짐

## 3. 퀵 정렬 (Quick Sort)
- 기준을 설정한 후 큰 수와 작은 수를 교환해 리스트를 반으로 나누는 방법으로 동작함
  - 큰 수와 작은 수를 교환하기 위한 기준이 'Pivot(피벗)'임
  - 퀵 정렬은 피벗을 정하고 리스트를 분할하는 방법에 따라 여러가지 방법으로 나뉠 수 있음
  - 자주 쓰이는 분할 방법은 호어 분할 방식 (Hoare Partition)

### 퀵 정렬의 단계
1. 분할(Divide)
   - 배열을 피벗을 기준으로 비균등하게 2개의 부분 배열(피벗을 중심으로 왼쪽: 피벗보다 작은 요소들, 오른쪽: 피벗보다 큰 요소들)로 분할
2. 정복(Conquer)
   - 부분 배열을 정렬. 부분 배열의 크기가 충분히 작지 않으면 순환 호출을 이용해 다시 분할 정복 방법을 적용
3. 결합(Combine)
   - 정렬된 부분 배열들을 하나의 배열에 합병.
   - 순환 호출이 한번 진행될 때마다 최소한 하나의 원소(피벗)는 최종적으로 위치가 정해지므로, 이 알고리즘은 반드시 끝난다는 것을 보장할 수 있음


### 코드
- 방법이 [더](https://im-developer.tistory.com/135)가 있으니 다시 확인할 것

### 시간 복잡도
- 평균 시간 복잡도는 `O(NlogN)`
  - 분할이 이루어지는 횟수가 기하급수적으로 감소하게 됨
- 최악의 경우 `O(N^2)`
  - 이미 데이터가 정렬되어 있는 경우에는 굉장히 느림
  - 삽입 정렬은 이미 데이터가 정렬되어 있는 경우에 가장 빠르게 동작함 

## 4. 계수 정렬 (Count sort)
- 특정한 조건이 부합할 때만 사용할 수 있는 방법
- 데이터가 정수 형태여야 하며, 범위가 제한적일때 사용 가능 
  - 모든 범위를 담을 수 있는 크기의 리스트를 선언해야 하기 때문

### 코드
```js
function countSort(arr) {
    let answer = '';
    let countArr = Array.from({length: (Math.max(...arr)+1)}, () => 0);

    for(let i = 0; i < arr.length; i++) {
        countArr[arr[i]] += 1;
    }
    for(let i = 0; i < countArr.length; i++) {
        for(let j = 0; j < countArr[i]; j++) {
            answer += i + '';
        }
    }
    return answer;
}

const arr = [5, 7, 9, 0, 3, 1, 0, 9, 9, 9, 6, 2, 4, 8, 2, 5, 8];
console.log(countSort(arr));
```

### 시간 복잡도
- `O(N+K)`
- 기수 정렬과 더불어 가장 빠른 방법

### 공간 복잡도
- 데이터가 0, 828282가 존재한다고 할 때, 리스트의 크기가 100만 개가 되도록 선언해야 함
- 항상 사용할 수 있는 게 아니고, 동일한 값을 가지는 데이터가 여러 개 등장할 때 적합함
- 즉, 데이터의 크기가 한정되어 있고 중복된 값이 많을수록 유리함

---
+ 병합 정렬
+ 힙 정렬