# 복잡도 - 알고리즘 효율성 분석

- 복잡도는 알고리즘 성능을 나타내는 척도이자, 알고리즘의 효율성을 분석할 때 이용
- 같은 기능을 수행하는 알고리즘이 있다면, 복잡도가 낮을수록 좋은 알고리즘
- 시간 복잡도, 공간 복잡도로 나뉨

## 1. 시간 복잡도 (time complexity)

- 문제를 해결하는 데 걸리는 시간, 입력의 함수 관계
- 작성한 프로그램이 모든 입력을 받아 처리하고 실행 결과를 출력하기까지 걸리는 시간
- 보통 빅오 표기법으로 나타냄
- 모든 입력에 대한 알고리즘에 필요한 시간이 10n^2 + 2인 코드 (시간 복잡도: O(n^2))

  ```js
  for(let i = 0; i < 10; i++) {  // 10 * n * n
    for(let j = 0; j < n; j++) {
        for(let k = 0; k < n; k++) {
            if(1) count += k;
        }
    }
  }

  for(let i = 0; i < n; i++) {  // n
    ...
  }
  ```

### 빅오(Big-O) 표기법

- 가장 빠르게 증가하는 항(= 가장 큰 영향을 끼치는 항)만 고려한 표기법
- 함수의 상한만을 나타냄
- 입력 범위 n을 기준으로 로직이 몇번 반복되는지 나타내는 것
- ✍🏻 **가장 큰 영향을 끼치는 항의 상수 인자를 빼고 나머지 항을 없앤 것**

> ✅ 코딩 테스트에서 중요한 것: **최악의 경우에 대한 연산 횟수**

### 시간 복잡도는 왜 필요한가?

- 코드를 효율적으로 개선시키기 위한 척도가 되기 때문

### 시간 복잡도의 속도 비교

| 빅오 표기법 | 알고리즘 명칭 | 설명                                                                                                          |
| :---------- | :------------ | :------------------------------------------------------------------------------------------------------------ |
| O(1)        | 상수형        | 입력량과 무관하게 실행 시간이 일정                                                                            |
| O(logn)     | 로그형        | 시간이 선형적으로 증가하면 n은 기하급수적으로 증가.<br> 데이터 입력량이 늘어날수록 단위 입력당 실행 시간 감소 |
| O(n)        | 선형          | 입력량에 비례하여 실행 시간 증가                                                                              |
| O(nlogn)    | 선형-로그형   | 입력량이 n배 늘어남 -> 실행 시간이 n배 조금 넘게 늘어남                                                       |
| O(n^2)      | 2차           | 입력량의 제곱에 비례해 실행 시간이 늘어남                                                                     |
| O(2^n)      | 지수형        | 입력이 추가될 때마다 실행시간이 2배로 늘어남                                                                  |
| O(n!)       | 계승형        | 입력이 추가될 때마다 실행 시간이 n배로 늘어남                                                                 |

> ✅ 빅오 표기법은 항상 절대적이지 않다. 실제 코딩테스트에서는 차수가작은 항들을 완전히 무시할 수 없는 경우도 존재한다.

### 일반적인 문제를 풀 때의 예시

- 시간 복잡도가 동일하더라도 실제 연산(사칙, 비교 연산 등) 횟수에서는 차이가 날 수 있음

| N의 범위   | 이용할 시간 복잡도 알고리즘 |
| :--------- | :-------------------------- |
| 500        | O(N^3)                      |
| 2,000      | O(N^2)                      |
| 100,000    | O(NlogN)                    |
| 10,000,000 | O(N)                        |

### 🚨 오메가 vs 세타 vs 빅오 표기법

| 표기법 |                                                                                    |
| :----- | :--------------------------------------------------------------------------------- |
| 오메가 | 알고리즘을 실행하는 데 걸리는 최소 시간을 측정                                     |
| 세타   | 알고리즘을 실행하는 데 걸리는 최소, 최대 시간 모두 측정                            |
| 빅오   | 알고리즘을 실행하는 데 걸리는 최대 시간(= 알고리즘 실행 시간이 최악인 경우)을 측정 |

## 2. 공간 복잡도 (space complaxity)

- 알고리즘을 위해 필요한 메모리의 양
- 프로그램을 실행시켰을 때 필요로하는 자원 공간의 양
  - 정적 변수로 선언된 것 이외에도 동적인 경우(ex. 재귀함수)도 포함
- JS에는 없지만 C언어 같이 '자료형의 크기'가 존재하는 언어에서, 자료형의 크기를 의미함

## 자료 구조에서의 평균 시간 복잡도

- 자료구조를 쓸 때에는 시간 복잡도를 잘 고려해야 함

| 자료구조                | 접근 (평균/최악) | 탐색           | 삽입           | 삭제           |
| :---------------------- | :--------------- | :------------- | :------------- | :------------- |
| Array                   | O(1)             | O(n)           | O(n)           | O(n)           |
| Stack                   | O(n)             | O(n)           | O(1)           | O(1)           |
| Queue                   | O(n)             | O(n)           | O(1)           | O(1)           |
| Doubly linked List      | O(n)             | O(n)           | O(1)           | O(1)           |
| Hash Table              | O(1) / O(n)      | O(1) / O(n)    | O(1) / O(n)    | O(1) / O(n)    |
| BST: Binary Search Tree | O(logn) / O(n)   | O(logn) / O(n) | O(logn) / O(n) | O(logn) / O(n) |
| AVL Tree                | O(logn)          | O(logn)        | O(logn)        | O(logn)        |
| Red-Black Tree          | O(logn)          | O(logn)        | O(logn)        | O(logn)        |
