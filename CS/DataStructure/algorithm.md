# 알고리즘 (Algorithm)

- 문제를 해결하기 위해 사용하는 일련의 **단계**

# 알고리즘의 3가지 유형

## 1. 분할 정복 알고리즘 (divide and conquer algorithm)

- 큰 문제를 여러 개의 작은 문제로 나누어 해결하고, 결과를 결합해 하나의 해결 방법을 얻는 알고리즘
- 큰 문제를 해결하기 위한 접근 방법

## 2. 탐욕 알고리즘 (greedy algorithm)

- 실행되는 순간마다 최상의 결정(가장 적합한 동작)을 내리는 알고리즘
- 그러나 항상 문제 전체를 해결하는 최적의 결정인지는 장담할 수 없음

## 3. 동적 프로그래밍, 동적 계획법 (dynamic programming)

- 과거에 내린 결정이 앞으로의 결정에 영향을 주는 알고리즘

### 탐욕 알고리즘과의 공통점

- 둘다 문제를 더 작은 단위로 나누는 것에 중점을 둠

### 탐욕 알고리즘과의 차이점

- 탐욕 알고리즘은 특정 순간에 최적인 해결법을 찾음 => 근사치를 구함
- 동적 프로그래밍은 문제를 해결하는 다양한 해결 방법을 찾아 **저장한 후 나중에 재사용**함 => 최적화함

# 알고리즘 분석 🙄

- 알고리즘의 효율성을 분석할 때에는 **시간 복잡도**와 **공간 복잡도**를 이용함
- 복잡도는 알고리즘 성능을 나타내는 척도이자 특정한 알고리즘이 계산적으로 얼마나 복잡한지를 나타냄
- 동일한 기능을 수행하는 알고리즘이 있다면 대부분 복잡도가 낮을수록 좋은 알고리즘

## 1. 시간 복잡도 (time complexity)

- **문제를 해결하는 데 걸리는 시간과 입력의 함수 관계**
- 작성한 프로그램이 모든 입력을 받아 이를 처리하고 실행 결과를 출력하는 데까지 걸리는 시간

## 1.1 시간 복잡도를 나타낼 때 가장 자주 쓰이는 방법: '빅오(Big-O) 표기법'

- 가장 빠르게 증가하는 항(가장 큰 영향을 끼치는 항)만 고려하는 표기법
- 함수의 상한만을 나타냄
- 입력 범위 n을 기준으로 로직이 몇 번 반복되는지 나타내는 것
- 코딩 테스트에서 중요한 것은 **최악의 경우에 대한 연산 횟수**

### 시간 복잡도가 필요한 이유

- 효율적인 코드로 개선하는 데 쓰이는 척도가 됨

| 빅오 표기법 | 알고리즘 명칭 | 설명                                                                                                            |
| :---------- | :------------ | :-------------------------------------------------------------------------------------------------------------- |
| O(1)        | 상수형        | 데이터 입력량과 무관하게 실행 시간이 일정함                                                                     |
| O(logn)     | 로그형        | 시간이 선형적으로 증가하면 n이 기하급수적으로 증가함. 데이터 입력량이 늘어날수록 단위 입력당 실행 시간이 줄어듦 |
| O(n)        | 선형          | 데이터 입력량에 비례하여 실행 시간이 늘어남                                                                     |
| O(nlogn)    | 선형-로그형   | 데이터 입력량이 n배 늘어나면 실행 시간이 n배 조금 넘게 늘어남                                                   |
| O(n^2)      | 2차           | 데이터 입력량의 제곱에 비례해 실행 시간이 늘어남                                                                |
| O(2^n)      | 지수형        | 데이터 입력이 추가될 때마다 실행시간이 2배로 늘어남                                                             |
| O(n!)       | 계승형        | 데이터 입력이 추가될 때마다 실행 시간이 n배로 늘어남                                                            |

### 빅오 표기법은 항상 절대적일까?

- X. 실제 코딩테스트에서는 차수가 작은 항들을 완전히 무시할 수 없는 경우도 종종 존재함

### 일반적인 문제를 풀 때의 예시

- 시간 복잡도가 동일하더라도 실제 연산 횟수에서는 차이가 날 수 있음

| N의 범위   | 이용할 시간 복잡도 알고리즘 |
| :--------- | :-------------------------- |
| 500        | O(N^3)                      |
| 2,000      | O(N^2)                      |
| 100,000    | O(NlogN)                    |
| 10,000,000 | O(N)                        |

> 연산: 사칙, 비교 연산 등을 의미함

## 1.2 오메가, 세타, 빅 오 표기법

- 오메가 표기법은 알고리즘을 실행하는 데 걸리는 최소 시간을 측정
- 세타 표기법은 알고리즘을 실행하는 데 걸리는 최소, 최대 시간을 모두 측정
- 빅 오 표기법은 알고리즘을 실행하는 데 걸리는 최대 시간을 측정
  - (= 알고리즘의 실행 시간이 최악인 경우)

## 2. 공간 복잡도 (space complaxity)

- 프로그램을 실행시켰을 때 필요로 하는 자원 공간의 양
- **알고리즘을 위해 필요한 메모리의 양**

# 자료 구조에서의 평균 시간 복잡도

| 자료구조                             | 접근    | 탐색    | 삽입    | 삭제    |
| :----------------------------------- | :------ | :------ | :------ | :------ |
| 배열 (array)                         | O(1)    | O(n)    | O(n)    | O(n)    |
| 스택 (stack)                         | O(n)    | O(n)    | O(1)    | O(1)    |
| 큐 (queue)                           | O(n)    | O(n)    | O(1)    | O(1)    |
| 이중 연결리스트 (doubly linked list) | O(n)    | O(n)    | O(1)    | O(1)    |
| 해시 테이블 (hash table)             | O(1)    | O(1)    | O(1)    | O(1)    |
| 이진 탐색트리 (BST)                  | O(logn) | O(logn) | O(logn) | O(logn) |
| AVL 트리                             | O(logn) | O(logn) | O(logn) | O(logn) |
| 레드 블랙 트리                       | O(logn) | O(logn) | O(logn) | O(logn) |
