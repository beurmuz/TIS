# 메모리 관리
- 메모리는 한정되어 있고, 이를 최대한으로 활용해야 한다.

## 가상 메모리 (Virtual memory)
- 메모리 관리 기법 중 하나
- 컴퓨터가 실제로 이용 가능한 메모리 자원을 추상화하여, 이를 매우 큰 메모리로 보이게 만드는 것
- 가상 메모리는 가상 주소와 실제 주소가 매핑되어 있고, 프로세스의 주소 정보가 들어있는 '페이지 테이블'로 관리된다.
  - 이때 속도 향상을 위해 TLB를 사용한다. 

> ✅ TLB: 메모리와 CPU사이에 있는 주소 변환을 위한 캐시. 페이지 테이블에 있는 리스트를 보관하며 CPU가 페이지 테이블까지 가지 않도록 함으로써 속도를 향상시킨다.

<img src='./img/memory_03.JPG'>

|주소|의미|
|:-:|:--|
|가상 주소 (Logical address)|가상적으로 주어진 주소|
|실제 주소(Physical address)|실제 메모리 상에 있는 주소|

- 가상 주소는 메모리관리장치(MMU)에 의해 실제 주소로 변환되고, 이로 인해 사용자는 실제 주소를 몰라도 프로그램을 구축할 수 있다. 

### 스와핑 (Swapping)
- 가상 메모리에는 존재하지만 실제 메모리(RAM)에는 존재하지 않은 데이터, 코드에 접근할 시 페이지 폴트가 발생한다.
- 이를 방지하기 위해 당장 사용하지 않는 영역을 하드디스크로 옮겨 필요할 때 다시 RAM으로 불러오고, 사용하지 않을 땐 다시 하드디스크로 내림으로써 RAM을 효과적으로 관리하는 것을 '스와핑'이라고 한다.

### 페이지 폴트 (page fault)
- **프로세스 주소 공간에는 존재**하나, **RAM에는 존재하지 않는 데이터에 접근했을 시 발생하는 것**을 의미한다.
- 운영체제는 아래의 과정으로 해당 데이터를 메모리로 가져와서 마치 페이지 폴트가 발생하지 않은 것처럼 프로그램이 작동하게끔 해준다.

|페이지 폴트와 그로 인한 스와핑이 이루어지는 과정|
|:-|
|1. CPU는 물리 메모리를 확인하여 해당 페이지가 없으면 트랩을 발생시켜 OS에 알린다.|
|2. OS는 CPU의 동작을 잠시 멈춘다.|
|3. OS는 페이지 테이블을 확인해 가상 메모리에 페이지가 존재하는지 확인하고, 없으면 프로세스를 중단하고 현재 물리 메모리에 비어있는 프레임이 있는지 찾는다.<br>물리 메모리에도 없으면 스와핑이 발동된다.|
|4. 비어 있는 프레임에 해당 페이지를 로드하고, 페이지 테이블을 최신화한다.|
|5. 중단되었던 CPU를 다시 시작한다.|

> ✅ 페이지(page): 가상 메모리를 사용하는 최소 크기 단위
> ✅ 프레임(frame): 실제 메모리를 사용하는 최소 크기 단위

## 스레싱 (Thrashing)

<img src='./img/memory_04'>

- 메모리에 너무 많은 프로세스가 동시에 올라가게 되면 스와핑이 많이 일어나 발생하는 것
- 스레싱은 메모리 페이지 폴트율이 높으며, 이는 컴퓨터의 심각한 성능 저하를 초래한다.
- 페이지 폴트가 발생하면 CPU이용률이 낮아지고, 이렇게 되면 OS는 CPU가 한가한 줄 알고 가용성을 더 높이기 위해 더 많은 프로세스를 메모리에 올린다. 이 과정이 계속 반복된다.

### 스레싱을 해결하는 방법
- 메모리를 늘린다.
- HDD를 사용할 경우 SDD로 바꾼다.
- 작업 세트와 PFF를 이용한다.

### 1. 작업 세트 (working Set)
- 프로세스의 과거 사용 이력인 지역성(Locality)을 통해 결정된 페이지 집합을 만들어서 미리 메모리에 로드하는 것을 의미한다.
- 미리 메모리에 로드할 경우 탐색에 드는 비용과 스와핑을 줄일 수 있다.

### 2. PFF (Page Fault Frequency)
- 상한선과 하한선을 만들어 페이지 폴트 빈도를 조절하는 방법
- 만약 상한선에 도달하면 페이지를 늘리고, 하한선에 도달하면 페이지를 줄이는 것이다.

## 메모리 할당
- 메모리에 프로그램을 할당할 때는 시작 메모리 위치, 메모리 할당 크기를 기반으로 할당한다.
- 메모리 할당은 연속 할당과 불연속 할당으로 나뉜다. 

### 연속 할당
- 메모리에 연속적으로 공간을 할당하는 것
- 연속 할당에는 고정 분할 방식과 가변 분할 방식이 있다.

1. 고정 분할 방식 (Fixed Partition Allocation)
- 메모리를 미리 나누어 관리하는 방식
- 메모리가 미리 나뉘어 있기 때문에 융통성이 없다.
- 내부 단편화가 발생한다.

2. 가변 분할 방식 (Variable Partition Allocation)
- 매 시점 프로그램의 크기에 맞게 동적으로 메모리를 나눠 사용하는 방식
- 내부 단편화는 발생하지 않으나 외부 단편화가 발생할 수 있다.
- 최초 적합, 최적 적합, 최악 적합이 있다.

|이름|설명|
|:-:|:--|
|최초 적합|위쪽 or 아래쪽부터 시작해 홀을 찾으면 바로 할당한다.|
|최적 적합|프로세스의 크기 이상인 공간 중 가장 작은 홀부터 할당한다.|
|최악 적합|프로세스의 크기와 가장 많이 차이나는 홀에 할당한다.|

> ✅ 내부 단편화 (internal fragmentation): 메모리를 나눈 크기보다 프로그램이 작아서 들어가지 못하는 공간이 많이 발생하는 현상
> ✅ 외부 단편화 (external fragmentation): 메모리를 나눈 크기보다 프로그램이 커서 들어가지 못하는 공간이 많이 발생하는 현상
> ✅ 홀 (hole): 할당할 수 있는 비어 있는 메모리 공간

### 불연속 할당
- 메모리를 연속적으로 할당하지 않는 방법
- 불연속 할당은 현대 OS가 쓰는 방법으로 페이징 기법이 있다. 

1. 페이징 (Paging)
- 동일한 크기의 페이지 단위로 나누어 메모리의 서로 다른 위치에 프로세스를 할당하는 방법
- 홀의 크기가 균이랗지 않은 문제가 없어지나 주소 변환이 복잡해진다.

2. 세그멘테이션 (Segmentation)
- 페이지 단위가 아닌 세그먼트(의미) 단위로 나누는 방식
- 프로세스는 코드, 데이터, 스택, 힙 등으로 이루어지는데, 코드와 데이터 등 이를 기반으로 나눌 수도 있으며 함수 단위로 나눌 수도 있다.
- 공유, 보안 측면에서 좋으나 홀 크기가 균일하지 않은 문제가 발생한다.

3. 페이지 세그멘테이션 (Paged Segmentation)
- 공유, 보안을 의미 단위의 세그먼트로 나누고, 물리적 메모리는 페이지로 나누는 것을 말한다.

## 페이지 교체 알고리즘
- 메모리는 한정되어 있어 스와핑이 많이 발생한다.
- 스와핑이 많이 발생하지 않도록 설계해야 하며, 스와핑은 페이지 교체 알고리즘을 기반으로 발생한다.

### 오프라인 알고리즘 (Offline Algorithm)
- 추후에 참조되는 페이지와 현재 할당하는 페이지를 바꾸는 기법
- 가장 좋은 방법이지만, 추후에 사용되는 프로세스를 우리가 알 수 없다는 문제점이 있다.
- 즉, 사용할 수 없는 알고리즘이나 다른 알고리즘과의 성능 비교에 대한 기준을 제공한다.

### FIFO (First In First Out)
- 가장 먼저 들어온 페이지를 교체 영역으로 가장 먼저 보내는 방법

### LRU (Least Recentle Used)
- 가장 오래전에 참조된 페이지를 바꾸는 방법
- 오래된 것을 파악하기 위해 각 페이지마다 계수기, 스택을 두어야 한다는 단점이 있다.
- LRU는 해시 테이블과 이중 연결 리스트를 이용해 구현할 수 있다. 
  - 해시 테이블은 이중 연결 리스트에서 빠르게 찾을 수 있도록 쓰고,
  - 이중 연결 리스트는 한정된 메모리를 나타낸다. 

### NUR (Not Used Recently)
- LRU에서 발전한 알고리즘
- clock 알고리즘이라고 하며, 먼저 0과 1을 가진 비트를 둔다. 
  - 1은 최근에 참조된 것
  - 0은 참조되지 않은 것
- 시계 방향을 돌면서 0을 찾고 0을 찾은 순간 해당 프로세스를 교체하고, 해당 부분을 1로 바꾸는 알고리즘이다.

### LFU (Least Frequently Used)
- 가장 참조 횟수가 적은 페이지를 교체하는 방법
- 즉, 많이 사용되지 않은 것을 교체하는 것이다.